/* A binary tree node
struct Node
{
    int data;
    Node* left, * right;
}; */

class Solution {
  public:
  
    // step second apply bfs on adjlist 
  int bfs(unordered_map<int, vector<int>>& graph, int a, int b) {
    queue<int> q;
    unordered_map<int, bool> visited;

    q.push(a);
    visited[a] = true;
    int dist = 0;

    while (!q.empty()) {
        int size = q.size();

        while (size--) {
            int node = q.front();
            q.pop();

            if (node == b) return dist;

            for (int neigh : graph[node]) {
                if (!visited[neigh]) {
                    visited[neigh] = true;
                    q.push(neigh);
                }
            }
        }
        dist++;
    }
    return -1; // safety
}
//  step first   buid adjency list 
void buildGraph(Node* root, unordered_map<int, vector<int>>& graph) {
    if (!root) return;

    if (root->left) {
        graph[root->data].push_back(root->left->data);
        graph[root->left->data].push_back(root->data);
        buildGraph(root->left, graph);
    }

    if (root->right) {
        graph[root->data].push_back(root->right->data);
        graph[root->right->data].push_back(root->data);
        buildGraph(root->right, graph);
    }
}

    /* Should return minimum distance between a and b
    in a tree with given root*/
    
    
    
      Node* solve(Node* &root, int a , int b ){
          if(root==NULL ) return NULL ;
            if(root->data == a || root->data == b) return root;
            Node* lefttree = solve(root->left,a,b);
            Node* righttree = solve(root->right,a,b);
            
            if(lefttree==NULL)  {
                return righttree;
            }else if(righttree==NULL){
                 return lefttree;
            }else
            return root;
          
          
      }
      
      
           int dist(Node *&root, int targetVal, int d){
        if(!root) return -1;
        if(root->data == targetVal) return d;
        int L = dist(root->left,targetVal, d+1);
        if(L != -1) return L;
        return dist(root->right,targetVal,d+1);
    }
    int findDist(Node* root, int a, int b) {
    //     // Your code here
    //  unordered_map<int, vector<int>> graph;

    // buildGraph(root, graph);

    // return bfs(graph, a, b);
    
    
    //   optimal solution .
    // step first find LCA 
    
        Node* lca = solve(root,a,b);
        
        int valueA = dist(lca,a,0);
        int valueB = dist(lca,b,0);
        
         return valueA+valueB;
    }
};
